//! Test generation logic.
use crate::commands::setup::run_generate_setup;
use std::fs;
use std::path::{Path, PathBuf};
use std::process::Command;

pub fn run_generate(package_path: &Path) -> Result<(), Box<dyn std::error::Error>> {
    // Always do setup first (same behavior as `generate-setup`).
    run_generate_setup(package_path)?;
    generate_tests(package_path)
}

#[derive(Debug, Clone)]
struct FnDecl {
    module_name: String,
    fn_name: String,
    params: Vec<ParamDecl>,
    return_ty: Option<String>,
    body_lines: Vec<String>,
    is_public: bool,
    is_entry: bool,
    is_test_only: bool,
    /// Tidewalker directive preconditions: functions that must be called first.
    requires: Vec<String>,
    numeric_effects: Vec<NumericEffect>,
    vector_effects: Vec<VectorEffect>,
    option_effects: Vec<OptionEffect>,
    string_effects: Vec<StringEffect>,
    calls: Vec<CallSite>,
}

#[derive(Debug, Clone)]
struct ParamDecl {
    name: String,
    ty: String,
}

#[derive(Debug, Clone)]
struct NumericEffect {
    base_var: String,
    field: String,
    op: NumericOp,
}

#[derive(Debug, Clone)]
struct VectorEffect {
    base_var: String,
    field: String,
    op: VectorOp,
}

#[derive(Debug, Clone)]
struct OptionEffect {
    base_var: String,
    field: String,
    op: OptionOp,
}

#[derive(Debug, Clone)]
struct StringEffect {
    base_var: String,
    field: String,
}

#[derive(Debug, Clone)]
struct AccessorSig {
    fn_name: String,
    param_ty: String,
}

#[derive(Debug, Clone)]
struct OptionAccessorSig {
    fn_name: String,
    param_ty: String,
    field: String,
    is_some_when_true: bool,
}

#[derive(Debug, Clone)]
enum NumericOp {
    Add(String),
    Sub(String),
    Mul(String),
    Div(String),
    Mod(String),
    Set(String),
    Changed,
}

#[derive(Debug, Clone)]
enum VectorOp {
    PushBack,
    PopBack,
    Insert,
    Remove,
    SwapRemove,
    Append {
        src_base_var: String,
        src_field: String,
    },
    ContentChanged,
}

#[derive(Debug, Clone)]
enum OptionOp {
    SetSome,
    SetNone,
    Changed,
}

#[derive(Debug, Default, Clone)]
struct StateChangeSummary {
    asserted: std::collections::BTreeSet<String>,
    potential: std::collections::BTreeSet<String>,
}

impl StateChangeSummary {
    fn add_asserted(&mut self, target: String) {
        self.potential.remove(&target);
        self.asserted.insert(target);
    }

    fn add_potential(&mut self, target: String) {
        if !self.asserted.contains(&target) {
            self.potential.insert(target);
        }
    }

    fn merge(&mut self, other: StateChangeSummary) {
        for t in other.asserted {
            self.add_asserted(t);
        }
        for t in other.potential {
            self.add_potential(t);
        }
    }
}

#[derive(Debug, Clone)]
struct CallSite {
    callee_fn: String,
    arg_exprs: Vec<String>,
}

fn generate_tests(package_path: &Path) -> Result<(), Box<dyn std::error::Error>> {
    use serde::Deserialize;

    #[derive(Deserialize)]
    struct MovePackage {
        package: Package,
    }
    #[derive(Deserialize)]
    struct Package {
        name: String,
    }

    let path = package_path
        .canonicalize()
        .unwrap_or_else(|_| package_path.to_path_buf());
    let move_toml_path = path.join("Move.toml");
    if !move_toml_path.is_file() {
        return Err(format!("Not a Move package: no Move.toml at {}", path.display()).into());
    }
    let toml_str = fs::read_to_string(&move_toml_path)?;
    let manifest: MovePackage = toml::from_str(&toml_str)?;
    let pkg_name = manifest.package.name;

    let status = Command::new("sui")
        .args(["move", "build", "-p", path.to_str().unwrap()])
        .status()?;
    if !status.success() {
        return Err("sui move build failed".into());
    }

    let src_root = path.join("build").join(&pkg_name).join("sources");
    if !src_root.is_dir() {
        return Err(format!("No build sources at {}", src_root.display()).into());
    }

    let mut move_files: Vec<PathBuf> = Vec::new();
    for entry in fs::read_dir(&src_root)? {
        let entry = entry?;
        let p = entry.path();
        if p.extension().map_or(false, |ext| ext == "move") {
            move_files.push(p);
        }
    }
    move_files.sort();

    let mut decls: Vec<FnDecl> = Vec::new();
    for file in &move_files {
        let content = fs::read_to_string(file)?;
        decls.extend(extract_public_fns(&content));
    }

    let mut skipped: Vec<(String, String, String)> = Vec::new(); // (module, fn, reason)
    let mut out: Vec<String> = Vec::new();
    out.push("// Generated by Tidewalker. Do not edit by hand.".to_string());
    out.push("#[test_only]".to_string());
    out.push(format!(
        "module {}::tidewalker_generated_tests {{",
        pkg_name
    ));
    out.push("    use sui::test_scenario;".to_string());
    out.push("    use sui::coin;".to_string());
    out.push("    use sui::coin::Coin;".to_string());
    out.push("    use sui::transfer;".to_string());
    out.push("".to_string());
    out.push("    const SUPER_USER: address = @0xA;".to_string());
    out.push("    const OTHER: address = @0xB;".to_string());
    out.push("".to_string());

    let accessor_map = build_accessor_map(&decls);
    let option_accessor_map = build_option_accessor_map(&decls);
    let helper_catalog = build_helper_catalog(&decls);
    let fn_lookup = build_fn_lookup(&decls);
    let effects_map = build_chained_effect_map(&decls, 4);
    let vector_effects_map = build_chained_vector_effect_map(&decls, 4);
    let option_effects_map = build_chained_option_effect_map(&decls, 4);
    let string_effects_map = build_chained_string_effect_map(&decls, 4);
    let deep_overflow_map = build_deep_overflow_map(&decls, 4);
    for d in decls {
        if d.is_test_only {
            continue;
        }
        if !d.is_public && !d.is_entry {
            continue;
        }
        let key = format!("{}::{}", d.module_name, d.fn_name);
        let resolved_effects = effects_map
            .get(&key)
            .cloned()
            .unwrap_or_else(|| d.numeric_effects.clone());
        let resolved_vector_effects = vector_effects_map
            .get(&key)
            .cloned()
            .unwrap_or_else(|| d.vector_effects.clone());
        let resolved_option_effects = option_effects_map
            .get(&key)
            .cloned()
            .unwrap_or_else(|| d.option_effects.clone());
        let resolved_string_effects = string_effects_map
            .get(&key)
            .cloned()
            .unwrap_or_else(|| d.string_effects.clone());
        let deep_overflow_paths = deep_overflow_map
            .get(&key)
            .cloned()
            .unwrap_or_default();
        if let Some(test_lines) = render_best_effort_test(
            &d,
            &accessor_map,
            &option_accessor_map,
            &helper_catalog,
            &fn_lookup,
            &resolved_effects,
            &resolved_vector_effects,
            &resolved_option_effects,
            &resolved_string_effects,
            &deep_overflow_paths,
        ) {
            for l in test_lines {
                out.push(format!("    {}", l));
            }
            out.push("".to_string());
        } else {
            skipped.push((
                d.module_name,
                d.fn_name,
                "unsupported signature for first-pass generation".to_string(),
            ));
        }
    }

    if !skipped.is_empty() {
        out.push("    // ---- Skipped functions (best-effort generator couldn’t synthesize calls yet) ----".to_string());
        for (m, f, r) in &skipped {
            out.push(format!("    // {}::{} — {}", m, f, r));
        }
        out.push("".to_string());
    }

    out.push("}".to_string());

    let tests_dir = path.join("tests");
    fs::create_dir_all(&tests_dir)?;
    let out_path = tests_dir.join("tidewalker_generated_tests.move");
    fs::write(&out_path, out.join("\n"))?;
    println!("Wrote {}", out_path.display());

    Ok(())
}

fn extract_public_fns(content: &str) -> Vec<FnDecl> {
    let lines: Vec<&str> = content.lines().collect();
    let mut module_name = String::new();
    for line in &lines {
        let t = line.trim();
        if t.starts_with("module ") {
            if let Some(rest) = t.strip_prefix("module ") {
                let until = rest.split_whitespace().next().unwrap_or(rest);
                module_name = until.trim_end_matches(';').to_string();
            }
            break;
        }
    }
    let option_fields_by_type = extract_option_fields_by_type(&lines);
    let string_fields_by_type = extract_string_fields_by_type(&lines);

    let mut out = Vec::new();
    let mut pending_test_only_attr = false;
    let mut pending_requires: Vec<String> = Vec::new();
    let mut i = 0;
    while i < lines.len() {
        let t = lines[i].trim();
        if t == "#[test_only]" {
            pending_test_only_attr = true;
            i += 1;
            continue;
        }
        if t.contains("@tidewalker") && t.contains("requires") {
            // Example: `/// @tidewalker requires increment`
            if let Some(after) = t.splitn(2, "requires").nth(1) {
                for part in after
                    .trim()
                    .split(|c: char| c == ',' || c.is_whitespace())
                    .map(|s| s.trim())
                    .filter(|s| !s.is_empty())
                {
                    pending_requires.push(part.to_string());
                }
            }
            i += 1;
            continue;
        }
        let (is_fn_decl, is_public, is_entry, name) = if t.starts_with("public entry fun ") {
            let after = &t["public entry fun ".len()..];
            let name = after
                .split(|c: char| c == '(' || c == '<' || c.is_whitespace())
                .next()
                .unwrap_or("")
                .to_string();
            (true, true, true, name)
        } else if t.starts_with("entry fun ") {
            let after = &t["entry fun ".len()..];
            let name = after
                .split(|c: char| c == '(' || c == '<' || c.is_whitespace())
                .next()
                .unwrap_or("")
                .to_string();
            (true, false, true, name)
        } else if t.starts_with("public fun ") {
            let after = &t["public fun ".len()..];
            let name = after
                .split(|c: char| c == '(' || c == '<' || c.is_whitespace())
                .next()
                .unwrap_or("")
                .to_string();
            (true, true, false, name)
        } else if t.starts_with("public(package) fun ") {
            let after = &t["public(package) fun ".len()..];
            let name = after
                .split(|c: char| c == '(' || c == '<' || c.is_whitespace())
                .next()
                .unwrap_or("")
                .to_string();
            (true, true, false, name)
        } else if t.starts_with("fun ") {
            let after = &t["fun ".len()..];
            let name = after
                .split(|c: char| c == '(' || c == '<' || c.is_whitespace())
                .next()
                .unwrap_or("")
                .to_string();
            (true, false, false, name)
        } else {
            (false, false, false, String::new())
        };
        if !is_fn_decl || name.is_empty() {
            // Keep #[test_only] pending across blank lines and comments (docs often sit between
            // the attribute and the function). Clear only on non-comment, non-empty content.
            if pending_test_only_attr
                && (t.is_empty() || t.starts_with("//") || t.starts_with("///"))
            {
                i += 1;
                continue;
            }
            if !t.is_empty() && !t.starts_with("//") && !t.starts_with("///") {
                pending_test_only_attr = false;
                pending_requires.clear();
            }
            i += 1;
            continue;
        }
        if name == "init" {
            pending_test_only_attr = false;
            pending_requires.clear();
            i += 1;
            continue;
        }
        let is_test_only = pending_test_only_attr;

        let fn_start = i;
        // Collect header across lines until we see ')'.
        let mut header = t.to_string();
        let mut j = i + 1;
        while j < lines.len() && !header.contains(')') {
            header.push(' ');
            header.push_str(lines[j].trim());
            j += 1;
        }
        pending_test_only_attr = false;

        let params_str = match header
            .split_once('(')
            .and_then(|(_, rest)| rest.split_once(')'))
            .map(|(p, _)| p)
        {
            Some(p) => p,
            None => continue,
        };
        let return_ty = extract_return_type(&header);
        let params = split_params(params_str)
            .into_iter()
            .filter_map(|p| {
                p.split_once(':').map(|(name, ty)| ParamDecl {
                    name: name.trim().to_string(),
                    ty: ty.trim().to_string(),
                })
            })
            .collect::<Vec<_>>();

        let mut brace_depth = 0i32;
        let mut body_start: Option<usize> = None;
        let mut body_end: Option<usize> = None;
        for (k, l) in lines.iter().enumerate().skip(fn_start) {
            for c in l.chars() {
                if c == '{' {
                    brace_depth += 1;
                    if brace_depth == 1 {
                        body_start = Some(k + 1);
                    }
                } else if c == '}' {
                    brace_depth -= 1;
                    if brace_depth == 0 {
                        body_end = Some(k);
                        break;
                    }
                }
            }
            if body_end.is_some() {
                break;
            }
        }
        let body_lines = match (body_start, body_end) {
            (Some(s), Some(e)) if s <= e => lines[s..=e]
                .iter()
                .map(|x| x.to_string())
                .collect::<Vec<_>>(),
            _ => Vec::new(),
        };
        let numeric_effects = extract_numeric_effects_from_body(&body_lines);
        let vector_effects = extract_vector_effects_from_body(&body_lines);
        let option_effects =
            extract_option_effects_from_body(&body_lines, &params, &option_fields_by_type);
        let string_effects =
            extract_string_effects_from_body(&body_lines, &params, &string_fields_by_type);
        let calls = extract_same_module_calls_from_body(&body_lines, &module_name);

        out.push(FnDecl {
            module_name: module_name.clone(),
            fn_name: name,
            params,
            return_ty,
            body_lines,
            is_public,
            is_entry,
            is_test_only,
            requires: std::mem::take(&mut pending_requires),
            numeric_effects,
            vector_effects,
            option_effects,
            string_effects,
            calls,
        });
        i = body_end.map(|e| e + 1).unwrap_or(j);
    }
    out
}

fn split_params(s: &str) -> Vec<String> {
    let mut out = Vec::new();
    let mut cur = String::new();
    let mut angle = 0i32;
    for ch in s.chars() {
        match ch {
            '<' => {
                angle += 1;
                cur.push(ch);
            }
            '>' => {
                angle -= 1;
                cur.push(ch);
            }
            ',' if angle == 0 => {
                let t = cur.trim();
                if !t.is_empty() {
                    out.push(t.to_string());
                }
                cur.clear();
            }
            _ => cur.push(ch),
        }
    }
    let t = cur.trim();
    if !t.is_empty() {
        out.push(t.to_string());
    }
    out
}

fn extract_option_fields_by_type(
    lines: &[&str],
) -> std::collections::HashMap<String, std::collections::HashSet<String>> {
    let mut out: std::collections::HashMap<String, std::collections::HashSet<String>> =
        std::collections::HashMap::new();
    let mut i = 0usize;
    while i < lines.len() {
        let t = lines[i].trim();
        let rest = if let Some(r) = t.strip_prefix("public struct ") {
            r
        } else if let Some(r) = t.strip_prefix("struct ") {
            r
        } else {
            i += 1;
            continue;
        };
        let struct_name = rest
            .split(|c: char| c == '{' || c == '<' || c.is_whitespace())
            .next()
            .unwrap_or("")
            .trim();
        if struct_name.is_empty() {
            i += 1;
            continue;
        }

        let mut brace_depth = 0i32;
        let mut saw_open = false;
        let mut j = i;
        let mut fields: std::collections::HashSet<String> = std::collections::HashSet::new();
        while j < lines.len() {
            let line = lines[j].trim();
            if saw_open {
                if let Some((field, ty_raw)) = line.split_once(':') {
                    let field = field.trim().trim_end_matches(',').trim();
                    let ty = ty_raw
                        .split("//")
                        .next()
                        .unwrap_or("")
                        .trim()
                        .trim_end_matches(',')
                        .trim();
                    if is_ident(field) && is_option_type(ty) {
                        fields.insert(field.to_string());
                    }
                }
            }
            for ch in line.chars() {
                if ch == '{' {
                    brace_depth += 1;
                    saw_open = true;
                } else if ch == '}' {
                    brace_depth -= 1;
                }
            }
            if saw_open && brace_depth <= 0 {
                break;
            }
            j += 1;
        }
        if !fields.is_empty() {
            out.insert(type_key_from_type_name(struct_name), fields);
        }
        i = j.saturating_add(1);
    }
    out
}

fn extract_string_fields_by_type(
    lines: &[&str],
) -> std::collections::HashMap<String, std::collections::HashSet<String>> {
    let mut out: std::collections::HashMap<String, std::collections::HashSet<String>> =
        std::collections::HashMap::new();
    let mut i = 0usize;
    while i < lines.len() {
        let t = lines[i].trim();
        let rest = if let Some(r) = t.strip_prefix("public struct ") {
            r
        } else if let Some(r) = t.strip_prefix("struct ") {
            r
        } else {
            i += 1;
            continue;
        };
        let struct_name = rest
            .split(|c: char| c == '{' || c == '<' || c.is_whitespace())
            .next()
            .unwrap_or("")
            .trim();
        if struct_name.is_empty() {
            i += 1;
            continue;
        }

        let mut brace_depth = 0i32;
        let mut saw_open = false;
        let mut j = i;
        let mut fields: std::collections::HashSet<String> = std::collections::HashSet::new();
        while j < lines.len() {
            let line = lines[j].trim();
            if saw_open {
                if let Some((field, ty_raw)) = line.split_once(':') {
                    let field = field.trim().trim_end_matches(',').trim();
                    let ty = ty_raw
                        .split("//")
                        .next()
                        .unwrap_or("")
                        .trim()
                        .trim_end_matches(',')
                        .trim();
                    if is_ident(field) && is_string_type(ty) {
                        fields.insert(field.to_string());
                    }
                }
            }
            for ch in line.chars() {
                if ch == '{' {
                    brace_depth += 1;
                    saw_open = true;
                } else if ch == '}' {
                    brace_depth -= 1;
                }
            }
            if saw_open && brace_depth <= 0 {
                break;
            }
            j += 1;
        }
        if !fields.is_empty() {
            out.insert(type_key_from_type_name(struct_name), fields);
        }
        i = j.saturating_add(1);
    }
    out
}

fn render_best_effort_test(
    d: &FnDecl,
    accessor_map: &std::collections::HashMap<String, Vec<AccessorSig>>,
    option_accessor_map: &std::collections::HashMap<String, Vec<OptionAccessorSig>>,
    helper_catalog: &std::collections::HashMap<String, ModuleHelperCatalog>,
    fn_lookup: &std::collections::HashMap<String, std::collections::HashMap<String, FnDecl>>,
    numeric_effects: &[NumericEffect],
    vector_effects: &[VectorEffect],
    option_effects: &[OptionEffect],
    string_effects: &[StringEffect],
    deep_overflow_paths: &std::collections::HashSet<String>,
) -> Option<Vec<String>> {
    let fq = format!("{}::{}", d.module_name, d.fn_name);
    let mut lines = Vec::new();
    lines.push("#[test]".to_string());
    lines.push(format!(
        "fun test_call_{}_{}() {{",
        d.module_name.split("::").last().unwrap_or("m"),
        d.fn_name
    ));
    lines.push("    let mut scenario = test_scenario::begin(SUPER_USER);".to_string());

    let mut args: Vec<String> = Vec::new();
    let mut needs_coin = false;
    let mut param_runtime: std::collections::HashMap<String, String> =
        std::collections::HashMap::new();
    let mut param_arg_values: std::collections::HashMap<String, String> =
        std::collections::HashMap::new();
    let mut object_needs: Vec<ObjectNeed> = Vec::new();

    for param in &d.params {
        let t = param.ty.trim();
        if t.contains("TxContext") {
            args.push("test_scenario::ctx(&mut scenario)".to_string());
        } else if t == "address" {
            let v = "OTHER".to_string();
            args.push(v.clone());
            param_arg_values.insert(param.name.clone(), v);
        } else if t == "u64" {
            let v = "1".to_string();
            args.push(v.clone());
            param_arg_values.insert(param.name.clone(), v);
        } else if t == "bool" {
            let v = "false".to_string();
            args.push(v.clone());
            param_arg_values.insert(param.name.clone(), v);
        } else if is_option_type(t) {
            args.push(option_none_expr_for_type(t));
        } else if is_string_type(t) {
            let v = "std::string::utf8(b\"tidewalker\")".to_string();
            args.push(v);
        } else if t.contains("Coin<") || t.contains("Coin <") {
            needs_coin = true;
            if t.starts_with("&mut") {
                args.push("&mut coin".to_string());
            } else {
                args.push("&coin".to_string());
            }
        } else if t.starts_with('&') {
            let obj = ObjectNeed::new(param);
            if obj.is_mut {
                args.push(format!("&mut {}", obj.var_name));
            } else {
                args.push(format!("&{}", obj.var_name));
            }
            param_runtime.insert(param.name.clone(), obj.var_name.clone());
            object_needs.push(obj);
        } else {
            return None;
        }
    }

    let mut shared_objects: Vec<ObjectNeed> = Vec::new();
    let mut owned_objects: Vec<ObjectNeed> = Vec::new();
    if !object_needs.is_empty() {
        let module_helpers = helper_catalog.get(&d.module_name)?;
        for obj in &object_needs {
            if module_helpers.shared_types.contains(&obj.type_key) {
                shared_objects.push(obj.clone());
            } else if module_helpers.owned_types.contains(&obj.type_key) {
                owned_objects.push(obj.clone());
            } else {
                return None;
            }
        }
    }
    let has_shared_objects = !shared_objects.is_empty();

    if has_shared_objects {
        lines.push("    {".to_string());
        for obj in &shared_objects {
            lines.push(format!(
                "        {}::create_and_share_{}_for_testing(test_scenario::ctx(&mut scenario));",
                d.module_name, obj.type_key
            ));
        }
        lines.push("    };".to_string());
        lines.push("    test_scenario::next_tx(&mut scenario, SUPER_USER);".to_string());
    }

    let mut object_vars_by_type: std::collections::HashMap<String, String> =
        std::collections::HashMap::new();
    for obj in &object_needs {
        object_vars_by_type
            .entry(obj.type_key.clone())
            .or_insert_with(|| obj.var_name.clone());
    }

    let (snapshot_before_lines, snapshot_after_lines, mut numeric_summary) = build_numeric_assertion_lines(
        d,
        numeric_effects,
        &param_runtime,
        &param_arg_values,
        accessor_map,
        deep_overflow_paths,
    );
    let (vector_before_lines, vector_after_lines, vector_summary) =
        build_vector_assertion_lines(d, vector_effects, &param_runtime, accessor_map, deep_overflow_paths);
    let (option_before_lines, option_after_lines, option_summary) =
        build_option_assertion_lines(d, option_effects, &param_runtime, option_accessor_map, deep_overflow_paths);
    let string_summary = build_string_summary(string_effects, &param_runtime, deep_overflow_paths);
    for eff in string_effects {
        let operator_target = format!("operator {}.{}", eff.base_var, eff.field);
        numeric_summary.asserted.remove(&operator_target);
        numeric_summary.potential.remove(&operator_target);
    }
    let mut state_summary = StateChangeSummary::default();
    state_summary.merge(numeric_summary);
    state_summary.merge(vector_summary);
    state_summary.merge(option_summary);
    state_summary.merge(string_summary);
    state_summary.merge(build_deep_chain_summary(deep_overflow_paths));
    let summary_lines = render_state_change_summary_lines(&state_summary);

    lines.push("    {".to_string());
    if needs_coin {
        lines.push("        let mut coin = coin::mint_for_testing<0x2::sui::SUI>(1000, test_scenario::ctx(&mut scenario));".to_string());
    }
    for obj in &owned_objects {
        let maybe_mut = if obj.is_mut { "mut " } else { "" };
        lines.push(format!(
            "        let {}{} = {}::create_{}_for_testing(test_scenario::ctx(&mut scenario));",
            maybe_mut, obj.var_name, d.module_name, obj.type_key
        ));
    }
    for obj in &shared_objects {
        let maybe_mut = if obj.is_mut { "mut " } else { "" };
        let obj_ty = qualify_type_for_module(&d.module_name, &obj.type_name);
        lines.push(format!(
            "        let {}{} = scenario.take_shared<{}>();",
            maybe_mut, obj.var_name, obj_ty
        ));
    }

    for req in &d.requires {
        if let Some(module_fns) = fn_lookup.get(&d.module_name) {
            if let Some(req_decl) = module_fns.get(req) {
                if let Some(req_args) =
                    synthesize_call_args_for_fn(req_decl, &object_vars_by_type, needs_coin)
                {
                    lines.push(format!(
                        "        {}::{}({});",
                        d.module_name,
                        req_decl.fn_name,
                        req_args.join(", ")
                    ));
                }
            }
        }
    }
    for l in snapshot_before_lines {
        lines.push(format!("        {}", l));
    }
    for l in vector_before_lines {
        lines.push(format!("        {}", l));
    }
    for l in option_before_lines {
        lines.push(format!("        {}", l));
    }
    lines.push(format!("        {}({});", fq, args.join(", ")));
    for l in snapshot_after_lines {
        lines.push(format!("        {}", l));
    }
    for l in vector_after_lines {
        lines.push(format!("        {}", l));
    }
    for l in option_after_lines {
        lines.push(format!("        {}", l));
    }
    for l in summary_lines {
        lines.push(format!("        {}", l));
    }
    for obj in &shared_objects {
        lines.push(format!(
            "        test_scenario::return_shared({});",
            obj.var_name
        ));
    }
    for obj in &owned_objects {
        lines.push(format!(
            "        transfer::public_transfer({}, SUPER_USER);",
            obj.var_name
        ));
    }
    if needs_coin {
        lines.push("        transfer::public_transfer(coin, SUPER_USER);".to_string());
    }
    lines.push("    };".to_string());

    // Ensure scenario is closed.
    lines.push("    test_scenario::end(scenario);".to_string());
    lines.push("}".to_string());
    Some(lines)
}

#[derive(Debug, Clone)]
struct ObjectNeed {
    type_name: String,
    type_key: String,
    var_name: String,
    is_mut: bool,
}

impl ObjectNeed {
    fn new(param: &ParamDecl) -> Self {
        let type_name = normalize_param_object_type(&param.ty);
        let type_key = type_key_from_type_name(&type_name);
        Self {
            type_name,
            type_key,
            var_name: format!("obj_{}", sanitize_ident(&param.name)),
            is_mut: param.ty.trim().starts_with("&mut"),
        }
    }
}

fn extract_numeric_effects_from_body(body_lines: &[String]) -> Vec<NumericEffect> {
    let mut effects = Vec::new();
    let mut aliases: std::collections::HashMap<String, String> = std::collections::HashMap::new();
    for line in body_lines {
        let no_comments = line.split("//").next().unwrap_or("").trim();
        if no_comments.is_empty() || no_comments.starts_with("assert!") {
            continue;
        }
        let stmt = no_comments.trim_end_matches(';').trim();
        if let Some((name, target)) = parse_alias_binding(stmt) {
            aliases.insert(name, target);
            continue;
        }
        if stmt.starts_with("let ") {
            if let Some(name) = parse_let_binding_name(stmt) {
                aliases.remove(&name);
            }
        }
        let (lhs, rhs) = match stmt.split_once('=') {
            Some((l, r)) => (l.trim(), r.trim()),
            None => continue,
        };
        if lhs.ends_with('!') || lhs.contains("==") {
            continue;
        }
        let (base_var, field) = match parse_field_access(lhs)
            .and_then(|(base, field)| resolve_effect_target(&base, &field, &aliases))
        {
            Some(parts) => parts,
            None => continue,
        };
        let lhs_norm = remove_whitespace(lhs);
        let rhs_norm = remove_whitespace(rhs);

        let op = if let Some(rest) = rhs_norm.strip_prefix(&lhs_norm) {
            let (op_char, raw_lit) = match rest.chars().next() {
                Some(c @ ('+' | '-' | '*' | '/' | '%')) => (c, rest[1..].trim()),
                _ => continue,
            };
            if let Some(lit) = parse_numeric_literal(raw_lit) {
                match op_char {
                    '+' => NumericOp::Add(lit),
                    '-' => NumericOp::Sub(lit),
                    '*' => NumericOp::Mul(lit),
                    '/' => NumericOp::Div(lit),
                    '%' => NumericOp::Mod(lit),
                    _ => continue,
                }
            } else if is_ident(raw_lit) {
                match op_char {
                    '+' => NumericOp::Add(raw_lit.to_string()),
                    '-' => NumericOp::Sub(raw_lit.to_string()),
                    '*' => NumericOp::Mul(raw_lit.to_string()),
                    '/' => NumericOp::Div(raw_lit.to_string()),
                    '%' => NumericOp::Mod(raw_lit.to_string()),
                    _ => continue,
                }
            } else {
                // We can still assert a state change happened even when exact delta is unknown.
                NumericOp::Changed
            }
        } else if let Some(v) = parse_numeric_literal(&rhs_norm) {
            NumericOp::Set(v)
        } else if is_ident(&rhs_norm) {
            NumericOp::Set(rhs_norm)
        } else {
            continue;
        };

        effects.push(NumericEffect {
            base_var,
            field,
            op,
        });
    }
    effects
}

fn extract_vector_effects_from_body(body_lines: &[String]) -> Vec<VectorEffect> {
    let mut out = Vec::new();
    let mut aliases: std::collections::HashMap<String, String> = std::collections::HashMap::new();
    for line in body_lines {
        let t = line
            .split("//")
            .next()
            .unwrap_or("")
            .trim()
            .trim_end_matches(';')
            .trim();
        if t.is_empty() {
            continue;
        }
        if let Some((name, target)) = parse_alias_binding(t) {
            aliases.insert(name, target);
            continue;
        }
        if t.starts_with("let ") {
            if let Some(name) = parse_let_binding_name(t) {
                aliases.remove(&name);
            }
        }
        if t.contains("==") {
            continue;
        }
        if let Some((base_var, field)) = parse_vector_method_target(t, "push_back(", &aliases) {
            out.push(VectorEffect {
                base_var,
                field,
                op: VectorOp::PushBack,
            });
            continue;
        }
        if let Some((base_var, field)) = parse_vector_method_target(t, "pop_back(", &aliases) {
            out.push(VectorEffect {
                base_var,
                field,
                op: VectorOp::PopBack,
            });
            continue;
        }
        if let Some((base_var, field)) = parse_vector_method_target(t, "insert(", &aliases) {
            out.push(VectorEffect {
                base_var,
                field,
                op: VectorOp::Insert,
            });
            continue;
        }
        if let Some((base_var, field)) = parse_vector_method_target(t, "remove(", &aliases) {
            out.push(VectorEffect {
                base_var,
                field,
                op: VectorOp::Remove,
            });
            continue;
        }
        if let Some((base_var, field)) = parse_vector_method_target(t, "swap_remove(", &aliases) {
            out.push(VectorEffect {
                base_var,
                field,
                op: VectorOp::SwapRemove,
            });
            continue;
        }
        if let Some((base_var, field)) = parse_vector_method_target(t, "append(", &aliases) {
            let src = extract_method_args(t, "append(")
                .and_then(|args| args.first().cloned())
                .and_then(|arg| parse_vector_target_expr(&arg, &aliases));
            if let Some((src_base_var, src_field)) = src {
                out.push(VectorEffect {
                    base_var,
                    field,
                    op: VectorOp::Append {
                        src_base_var,
                        src_field,
                    },
                });
            } else {
                out.push(VectorEffect {
                    base_var,
                    field,
                    op: VectorOp::ContentChanged,
                });
            }
            continue;
        }
        if let Some((base_var, field)) = parse_vector_method_target(t, "reverse(", &aliases) {
            out.push(VectorEffect {
                base_var,
                field,
                op: VectorOp::ContentChanged,
            });
            continue;
        }
        if let Some((base_var, field)) = parse_vector_method_target(t, "swap(", &aliases) {
            out.push(VectorEffect {
                base_var,
                field,
                op: VectorOp::ContentChanged,
            });
            continue;
        }
        if let Some((base_var, field)) = parse_vector_namespace_target(t, "vector::push_back(", &aliases) {
            out.push(VectorEffect {
                base_var,
                field,
                op: VectorOp::PushBack,
            });
            continue;
        }
        if let Some((base_var, field)) = parse_vector_namespace_target(t, "vector::pop_back(", &aliases) {
            out.push(VectorEffect {
                base_var,
                field,
                op: VectorOp::PopBack,
            });
            continue;
        }
        if let Some((base_var, field)) = parse_vector_namespace_target(t, "vector::insert(", &aliases) {
            out.push(VectorEffect {
                base_var,
                field,
                op: VectorOp::Insert,
            });
            continue;
        }
        if let Some((base_var, field)) = parse_vector_namespace_target(t, "vector::remove(", &aliases) {
            out.push(VectorEffect {
                base_var,
                field,
                op: VectorOp::Remove,
            });
            continue;
        }
        if let Some((base_var, field)) = parse_vector_namespace_target(t, "vector::swap_remove(", &aliases) {
            out.push(VectorEffect {
                base_var,
                field,
                op: VectorOp::SwapRemove,
            });
            continue;
        }
        if let Some((base_var, field)) = parse_vector_namespace_target(t, "vector::append(", &aliases) {
            let src = extract_namespace_args(t, "vector::append(")
                .and_then(|args| args.get(1).cloned())
                .and_then(|arg| parse_vector_target_expr(&arg, &aliases));
            if let Some((src_base_var, src_field)) = src {
                out.push(VectorEffect {
                    base_var,
                    field,
                    op: VectorOp::Append {
                        src_base_var,
                        src_field,
                    },
                });
            } else {
                out.push(VectorEffect {
                    base_var,
                    field,
                    op: VectorOp::ContentChanged,
                });
            }
            continue;
        }
        if let Some((base_var, field)) = parse_vector_namespace_target(t, "vector::reverse(", &aliases) {
            out.push(VectorEffect {
                base_var,
                field,
                op: VectorOp::ContentChanged,
            });
            continue;
        }
        if let Some((base_var, field)) = parse_vector_namespace_target(t, "vector::swap(", &aliases) {
            out.push(VectorEffect {
                base_var,
                field,
                op: VectorOp::ContentChanged,
            });
            continue;
        }
        if let Some((lhs, _)) = t.split_once('=') {
            let lhs = lhs.trim();
            if lhs.contains('[') && lhs.contains(']') {
                let base = lhs.split('[').next().unwrap_or("").trim();
                if let Some((base_var, field)) = parse_vector_target_expr(base, &aliases) {
                    out.push(VectorEffect {
                        base_var,
                        field,
                        op: VectorOp::ContentChanged,
                    });
                }
            }
        }
    }
    out
}

fn extract_option_effects_from_body(
    body_lines: &[String],
    params: &[ParamDecl],
    option_fields_by_type: &std::collections::HashMap<String, std::collections::HashSet<String>>,
) -> Vec<OptionEffect> {
    let mut out = Vec::new();
    let mut aliases: std::collections::HashMap<String, String> = std::collections::HashMap::new();
    let mut seen: std::collections::HashSet<String> = std::collections::HashSet::new();

    let mut param_option_fields: std::collections::HashMap<String, std::collections::HashSet<String>> =
        std::collections::HashMap::new();
    for p in params {
        let ty = normalize_param_object_type(&p.ty);
        let key = type_key_from_type_name(&ty);
        if let Some(fields) = option_fields_by_type.get(&key) {
            param_option_fields.insert(p.name.clone(), fields.clone());
        }
    }

    for line in body_lines {
        let no_comments = line.split("//").next().unwrap_or("").trim();
        if no_comments.is_empty() {
            continue;
        }
        let stmt = no_comments.trim_end_matches(';').trim();
        for borrow_target in extract_mut_borrow_targets(stmt) {
            let resolved = if let Some((base, field)) = parse_field_access(&borrow_target)
                .and_then(|(base, field)| resolve_effect_target(&base, &field, &aliases))
            {
                Some((base, field))
            } else if is_ident(&borrow_target) {
                parse_simple_base_field(&resolve_alias_path(&borrow_target, &aliases))
            } else {
                None
            };
            if let Some((base_var, field)) = resolved {
                if let Some(fields) = param_option_fields.get(&base_var) {
                    if fields.contains(&field) {
                        let sig = format!("{}::{}::{:?}", base_var, field, OptionOp::Changed);
                        if seen.insert(sig) {
                            out.push(OptionEffect {
                                base_var,
                                field,
                                op: OptionOp::Changed,
                            });
                        }
                    }
                }
            }
        }
        if let Some((name, target)) = parse_alias_binding(stmt) {
            aliases.insert(name, target);
            continue;
        }
        if stmt.starts_with("let ") {
            if let Some(name) = parse_let_binding_name(stmt) {
                aliases.remove(&name);
            }
        }
        let (lhs, rhs) = match stmt.split_once('=') {
            Some((l, r)) if !l.contains("==") && !r.contains("==") => (l.trim(), r.trim()),
            _ => continue,
        };
        if lhs.ends_with('!') || lhs.contains('[') || lhs.contains(']') {
            continue;
        }

        let (base_var, field) = match parse_field_access(lhs)
            .and_then(|(base, field)| resolve_effect_target(&base, &field, &aliases))
        {
            Some(parts) => parts,
            None => continue,
        };
        let fields = match param_option_fields.get(&base_var) {
            Some(v) => v,
            None => continue,
        };
        if !fields.contains(&field) {
            continue;
        }

        let op = parse_option_write_op(rhs);
        let sig = format!("{}::{}::{:?}", base_var, field, op);
        if seen.insert(sig) {
            out.push(OptionEffect {
                base_var,
                field,
                op,
            });
        }
    }

    out
}

fn parse_option_write_op(rhs: &str) -> OptionOp {
    let norm = remove_whitespace(rhs);
    if norm.contains("option::some(") {
        OptionOp::SetSome
    } else if norm.contains("option::none(") {
        OptionOp::SetNone
    } else {
        OptionOp::Changed
    }
}

fn extract_string_effects_from_body(
    body_lines: &[String],
    params: &[ParamDecl],
    string_fields_by_type: &std::collections::HashMap<String, std::collections::HashSet<String>>,
) -> Vec<StringEffect> {
    let mut out = Vec::new();
    let mut aliases: std::collections::HashMap<String, String> = std::collections::HashMap::new();
    let mut seen: std::collections::HashSet<String> = std::collections::HashSet::new();

    let mut param_string_fields: std::collections::HashMap<String, std::collections::HashSet<String>> =
        std::collections::HashMap::new();
    for p in params {
        let ty = normalize_param_object_type(&p.ty);
        let key = type_key_from_type_name(&ty);
        if let Some(fields) = string_fields_by_type.get(&key) {
            param_string_fields.insert(p.name.clone(), fields.clone());
        }
    }

    for line in body_lines {
        let no_comments = line.split("//").next().unwrap_or("").trim();
        if no_comments.is_empty() {
            continue;
        }
        let stmt = no_comments.trim_end_matches(';').trim();
        for borrow_target in extract_mut_borrow_targets(stmt) {
            let resolved = if let Some((base, field)) = parse_field_access(&borrow_target)
                .and_then(|(base, field)| resolve_effect_target(&base, &field, &aliases))
            {
                Some((base, field))
            } else if is_ident(&borrow_target) {
                parse_simple_base_field(&resolve_alias_path(&borrow_target, &aliases))
            } else {
                None
            };
            if let Some((base_var, field)) = resolved {
                if let Some(fields) = param_string_fields.get(&base_var) {
                    if fields.contains(&field) {
                        let sig = format!("{}.{}", base_var, field);
                        if seen.insert(sig) {
                            out.push(StringEffect { base_var, field });
                        }
                    }
                }
            }
        }
        if let Some((name, target)) = parse_alias_binding(stmt) {
            aliases.insert(name, target);
            continue;
        }
        if stmt.starts_with("let ") {
            if let Some(name) = parse_let_binding_name(stmt) {
                aliases.remove(&name);
            }
        }
        let (lhs, _rhs) = match stmt.split_once('=') {
            Some((l, r)) if !l.contains("==") && !r.contains("==") => (l.trim(), r.trim()),
            _ => continue,
        };
        if lhs.ends_with('!') || lhs.contains('[') || lhs.contains(']') {
            continue;
        }

        let (base_var, field) = match parse_field_access(lhs)
            .and_then(|(base, field)| resolve_effect_target(&base, &field, &aliases))
        {
            Some(parts) => parts,
            None => continue,
        };
        let fields = match param_string_fields.get(&base_var) {
            Some(v) => v,
            None => continue,
        };
        if !fields.contains(&field) {
            continue;
        }
        let sig = format!("{}.{}", base_var, field);
        if seen.insert(sig) {
            out.push(StringEffect { base_var, field });
        }
    }

    out
}

fn extract_mut_borrow_targets(stmt: &str) -> Vec<String> {
    let mut out = Vec::new();
    for part in stmt.split("&mut").skip(1) {
        let mut cand = part.trim();
        while let Some(rest) = cand.strip_prefix('(') {
            cand = rest.trim_start();
        }
        let end = cand
            .find(|c: char| c == ',' || c == ')' || c == ';' || c == '=')
            .unwrap_or(cand.len());
        let token = cand[..end]
            .trim()
            .trim_matches('(')
            .trim_matches(')')
            .trim();
        if !token.is_empty() {
            out.push(token.to_string());
        }
    }
    out
}

fn parse_vector_method_target(
    line: &str,
    method_prefix: &str,
    aliases: &std::collections::HashMap<String, String>,
) -> Option<(String, String)> {
    // Example: counter.history.push_back(x)
    let idx = line.find(method_prefix)?;
    let lhs = line[..idx].trim_end_matches('.').trim();
    parse_vector_target_expr(lhs, aliases)
}

fn parse_vector_namespace_target(
    line: &str,
    call_prefix: &str,
    aliases: &std::collections::HashMap<String, String>,
) -> Option<(String, String)> {
    // Example: vector::push_back(&mut counter.history, x)
    let args = extract_namespace_args(line, call_prefix)?;
    parse_vector_target_expr(args.first()?.as_str(), aliases)
}

fn parse_vector_target_expr(
    arg: &str,
    aliases: &std::collections::HashMap<String, String>,
) -> Option<(String, String)> {
    let first_arg = arg
        .trim()
        .trim_start_matches("&mut")
        .trim_start_matches('&')
        .trim();
    if let Some((base, field)) = parse_field_access(first_arg) {
        return resolve_effect_target(&base, &field, aliases);
    }
    if is_ident(first_arg) {
        let resolved = resolve_alias_path(first_arg, aliases);
        return parse_simple_base_field(&resolved);
    }
    None
}

fn parse_let_binding_name(stmt: &str) -> Option<String> {
    let rest = stmt.strip_prefix("let ")?.trim();
    let lhs = rest.split_once('=').map(|(l, _)| l).unwrap_or(rest).trim();
    let lhs = lhs.strip_prefix("mut ").unwrap_or(lhs).trim();
    let name = lhs.split(|c: char| c == ':' || c.is_whitespace()).next()?.trim();
    if is_ident(name) {
        Some(name.to_string())
    } else {
        None
    }
}

fn parse_alias_binding(stmt: &str) -> Option<(String, String)> {
    let name = parse_let_binding_name(stmt)?;
    let rhs = stmt.split_once('=')?.1.trim().trim_end_matches(';').trim();
    let rhs = rhs.trim().trim_matches('(').trim_matches(')').trim();
    let target = rhs
        .strip_prefix("&mut ")
        .or_else(|| rhs.strip_prefix('&'))
        .unwrap_or(rhs)
        .trim()
        .trim_matches('(')
        .trim_matches(')')
        .trim();
    if is_ident(target) || parse_simple_base_field(target).is_some() {
        Some((name, target.to_string()))
    } else {
        None
    }
}

fn resolve_alias_path(
    name: &str,
    aliases: &std::collections::HashMap<String, String>,
) -> String {
    let mut cur = name.to_string();
    let mut seen: std::collections::HashSet<String> = std::collections::HashSet::new();
    while is_ident(&cur) {
        if !seen.insert(cur.clone()) {
            break;
        }
        match aliases.get(&cur) {
            Some(next) => cur = next.clone(),
            None => break,
        }
    }
    cur
}

fn parse_simple_base_field(path: &str) -> Option<(String, String)> {
    let mut parts = path.split('.');
    let base = parts.next()?.trim();
    let field = parts.next()?.trim();
    if parts.next().is_some() {
        return None;
    }
    if is_ident(base) && is_ident(field) {
        Some((base.to_string(), field.to_string()))
    } else {
        None
    }
}

fn resolve_effect_target(
    base: &str,
    field: &str,
    aliases: &std::collections::HashMap<String, String>,
) -> Option<(String, String)> {
    let resolved = resolve_alias_path(base, aliases);
    if is_ident(&resolved) {
        return Some((resolved, field.to_string()));
    }
    if let Some((resolved_base, resolved_field)) = parse_simple_base_field(&resolved) {
        // If alias points to a field itself (e.g. alias -> counter.history), we only
        // support direct tracking of that field target.
        if field == resolved_field {
            return Some((resolved_base, resolved_field));
        }
    }
    None
}

fn extract_method_args(line: &str, method_prefix: &str) -> Option<Vec<String>> {
    let idx = line.find(method_prefix)?;
    let after = line[idx + method_prefix.len()..].trim();
    let args_raw = after.strip_suffix(')')?;
    Some(split_args(args_raw))
}

fn extract_namespace_args(line: &str, call_prefix: &str) -> Option<Vec<String>> {
    let after = line.split_once(call_prefix)?.1.trim();
    let args_raw = after.strip_suffix(')')?;
    Some(split_args(args_raw))
}

fn extract_return_type(header: &str) -> Option<String> {
    let after_paren = header.split_once(')')?.1.trim();
    let after_colon = after_paren.strip_prefix(':')?;
    let before_brace = after_colon.split('{').next().unwrap_or(after_colon).trim();
    if before_brace.is_empty() {
        None
    } else {
        Some(before_brace.to_string())
    }
}

fn extract_same_module_calls_from_body(body_lines: &[String], module_name: &str) -> Vec<CallSite> {
    let module_short = module_name.split("::").last().unwrap_or(module_name);
    let mut out = Vec::new();

    for line in body_lines {
        let text = line.split("//").next().unwrap_or("");
        let chars: Vec<char> = text.chars().collect();
        let mut i = 0usize;
        while i < chars.len() {
            if chars[i] != '(' || i == 0 {
                i += 1;
                continue;
            }
            let mut j: isize = (i as isize) - 1;
            while j >= 0 && chars[j as usize].is_whitespace() {
                j -= 1;
            }
            if j < 0 {
                i += 1;
                continue;
            }
            let end = j as usize;
            let mut start = end;
            while start > 0 {
                let c = chars[start];
                if c.is_ascii_alphanumeric() || c == '_' || c == ':' {
                    start -= 1;
                } else {
                    break;
                }
            }
            if !(chars[start].is_ascii_alphanumeric() || chars[start] == '_' || chars[start] == ':')
            {
                start += 1;
            }
            if start > end {
                i += 1;
                continue;
            }
            if start > 0 && chars[start - 1] == '.' {
                i += 1;
                continue;
            }
            let token: String = chars[start..=end].iter().collect();
            if token.is_empty() || token == "assert" {
                i += 1;
                continue;
            }

            let callee = if token.contains("::") {
                if token.starts_with("Self::") {
                    token.split("::").last().unwrap_or("").to_string()
                } else if token.starts_with(&format!("{}::", module_short)) {
                    token.split("::").last().unwrap_or("").to_string()
                } else {
                    i += 1;
                    continue;
                }
            } else {
                token
            };
            if callee.is_empty() {
                i += 1;
                continue;
            }

            let mut depth = 1i32;
            let mut k = i + 1;
            while k < chars.len() {
                if chars[k] == '(' {
                    depth += 1;
                } else if chars[k] == ')' {
                    depth -= 1;
                    if depth == 0 {
                        break;
                    }
                }
                k += 1;
            }
            if k >= chars.len() {
                i += 1;
                continue;
            }

            let args_raw: String = chars[i + 1..k].iter().collect();
            out.push(CallSite {
                callee_fn: callee,
                arg_exprs: split_args(&args_raw),
            });
            i = k + 1;
        }
    }

    out
}

fn split_args(s: &str) -> Vec<String> {
    let mut out = Vec::new();
    let mut cur = String::new();
    let mut angle = 0i32;
    let mut paren = 0i32;
    let mut bracket = 0i32;
    for ch in s.chars() {
        match ch {
            '<' => {
                angle += 1;
                cur.push(ch);
            }
            '>' => {
                angle -= 1;
                cur.push(ch);
            }
            '(' => {
                paren += 1;
                cur.push(ch);
            }
            ')' => {
                paren -= 1;
                cur.push(ch);
            }
            '[' => {
                bracket += 1;
                cur.push(ch);
            }
            ']' => {
                bracket -= 1;
                cur.push(ch);
            }
            ',' if angle == 0 && paren == 0 && bracket == 0 => {
                let t = cur.trim();
                if !t.is_empty() {
                    out.push(t.to_string());
                }
                cur.clear();
            }
            _ => cur.push(ch),
        }
    }
    let t = cur.trim();
    if !t.is_empty() {
        out.push(t.to_string());
    }
    out
}

fn parse_field_access(expr: &str) -> Option<(String, String)> {
    let norm = remove_whitespace(expr);
    if norm.contains('(') || norm.contains(')') || norm.matches('.').count() != 1 {
        return None;
    }
    let (base, field) = norm.split_once('.')?;
    if base.is_empty() || field.is_empty() {
        return None;
    }
    if !is_ident(base) || !is_ident(field) {
        return None;
    }
    Some((base.to_string(), field.to_string()))
}

fn remove_whitespace(s: &str) -> String {
    s.chars().filter(|c| !c.is_whitespace()).collect::<String>()
}

fn parse_numeric_literal(raw: &str) -> Option<String> {
    let mut lit = raw.trim();
    while lit.starts_with('(') && lit.ends_with(')') && lit.len() >= 2 {
        lit = &lit[1..lit.len() - 1];
        lit = lit.trim();
    }
    if lit.is_empty() {
        return None;
    }
    if lit.chars().all(|c| c.is_ascii_digit() || c == '_')
        && lit.chars().any(|c| c.is_ascii_digit())
    {
        return Some(lit.to_string());
    }
    None
}

fn is_ident(s: &str) -> bool {
    s.chars().all(|c| c.is_ascii_alphanumeric() || c == '_')
}

fn is_string_type(ty: &str) -> bool {
    let norm = ty.trim().replace(' ', "");
    norm == "String" || norm.ends_with("string::String")
}

fn is_option_type(ty: &str) -> bool {
    let norm = ty.trim().replace(' ', "");
    norm.starts_with("Option<") || norm.contains("::option::Option<")
}

fn option_none_expr_for_type(ty: &str) -> String {
    if let Some(inner) = extract_option_inner_type(ty) {
        format!("std::option::none<{}>()", inner)
    } else {
        "std::option::none()".to_string()
    }
}

fn extract_option_inner_type(ty: &str) -> Option<String> {
    let start = ty.find('<')?;
    let mut depth = 0i32;
    let mut end_idx: Option<usize> = None;
    for (i, ch) in ty.char_indices().skip(start) {
        if ch == '<' {
            depth += 1;
        } else if ch == '>' {
            depth -= 1;
            if depth == 0 {
                end_idx = Some(i);
                break;
            }
        }
    }
    let end = end_idx?;
    let inner = ty[start + 1..end].trim();
    if inner.is_empty() {
        None
    } else {
        Some(inner.to_string())
    }
}

fn sanitize_ident(s: &str) -> String {
    s.chars()
        .map(|c| {
            if c.is_ascii_alphanumeric() || c == '_' {
                c
            } else {
                '_'
            }
        })
        .collect::<String>()
}

fn is_numeric_type(ty: &str) -> bool {
    matches!(ty.trim(), "u8" | "u16" | "u32" | "u64" | "u128" | "u256")
}

fn normalize_param_object_type(ty: &str) -> String {
    ty.replace("&mut", "").replace('&', "").trim().to_string()
}

fn type_key_from_type_name(type_name: &str) -> String {
    let clean = type_name.trim();
    let no_generics = clean.split('<').next().unwrap_or(clean).trim();
    no_generics
        .split("::")
        .last()
        .unwrap_or(no_generics)
        .trim()
        .to_lowercase()
}

fn qualify_type_for_module(module_name: &str, type_name: &str) -> String {
    let clean = type_name.trim();
    if clean.contains("::") {
        clean.to_string()
    } else {
        format!("{}::{}", module_name, clean)
    }
}

fn build_accessor_map(decls: &[FnDecl]) -> std::collections::HashMap<String, Vec<AccessorSig>> {
    let mut out: std::collections::HashMap<String, Vec<AccessorSig>> =
        std::collections::HashMap::new();
    for d in decls {
        if d.is_test_only || !d.is_public {
            continue;
        }
        if d.params.len() != 1 {
            continue;
        }
        let ret = match &d.return_ty {
            Some(r) if is_numeric_type(r) => r,
            _ => continue,
        };
        let pty = d.params[0].ty.trim();
        if !pty.starts_with('&') {
            continue;
        }
        let _ = ret; // keep explicit intent: numeric accessor only
        out.entry(d.module_name.clone())
            .or_default()
            .push(AccessorSig {
                fn_name: d.fn_name.clone(),
                param_ty: normalize_param_object_type(pty),
            });
    }
    out
}

fn build_option_accessor_map(
    decls: &[FnDecl],
) -> std::collections::HashMap<String, Vec<OptionAccessorSig>> {
    let mut out: std::collections::HashMap<String, Vec<OptionAccessorSig>> =
        std::collections::HashMap::new();
    for d in decls {
        if d.is_test_only || !d.is_public {
            continue;
        }
        let sig = match parse_option_accessor_sig(d) {
            Some(v) => v,
            None => continue,
        };
        out.entry(d.module_name.clone()).or_default().push(sig);
    }
    out
}

fn parse_option_accessor_sig(d: &FnDecl) -> Option<OptionAccessorSig> {
    if d.params.len() != 1 {
        return None;
    }
    let ret = d.return_ty.as_ref()?.trim();
    if ret != "bool" {
        return None;
    }
    let param = d.params.first()?;
    if !param.ty.trim().starts_with('&') {
        return None;
    }
    let param_ty = normalize_param_object_type(&param.ty);
    let param_name = param.name.as_str();

    for line in &d.body_lines {
        let stmt = line.split("//").next().unwrap_or("").trim();
        if stmt.is_empty() {
            continue;
        }
        let stmt = stmt.trim_end_matches(';').trim();
        if let Some((field, is_some_when_true)) = parse_option_presence_from_expr(stmt, param_name) {
            return Some(OptionAccessorSig {
                fn_name: d.fn_name.clone(),
                param_ty: param_ty.clone(),
                field,
                is_some_when_true,
            });
        }
    }
    None
}

fn parse_option_presence_from_expr(expr: &str, param_name: &str) -> Option<(String, bool)> {
    let norm = remove_whitespace(expr);
    for (needle, is_some_when_true) in [("option::is_some(", true), ("option::is_none(", false)] {
        let idx = match norm.find(needle) {
            Some(v) => v,
            None => continue,
        };
        let after = &norm[idx + needle.len()..];
        let arg = match after.split(')').next() {
            Some(v) => v.trim_start_matches('&').trim(),
            None => continue,
        };
        let (base, field) = match parse_field_access(arg) {
            Some(v) => v,
            None => continue,
        };
        if base == param_name {
            return Some((field, is_some_when_true));
        }
    }
    None
}

#[derive(Debug, Default)]
struct ModuleHelperCatalog {
    shared_types: std::collections::HashSet<String>,
    owned_types: std::collections::HashSet<String>,
}

fn build_helper_catalog(
    decls: &[FnDecl],
) -> std::collections::HashMap<String, ModuleHelperCatalog> {
    let mut out: std::collections::HashMap<String, ModuleHelperCatalog> =
        std::collections::HashMap::new();
    for d in decls {
        if !d.is_test_only {
            continue;
        }
        if let Some(type_key) = d
            .fn_name
            .strip_prefix("create_and_share_")
            .and_then(|x| x.strip_suffix("_for_testing"))
        {
            out.entry(d.module_name.clone())
                .or_default()
                .shared_types
                .insert(type_key.to_string());
            continue;
        }
        if let Some(type_key) = d
            .fn_name
            .strip_prefix("create_")
            .and_then(|x| x.strip_suffix("_for_testing"))
        {
            out.entry(d.module_name.clone())
                .or_default()
                .owned_types
                .insert(type_key.to_string());
        }
    }
    out
}

fn build_fn_lookup(
    decls: &[FnDecl],
) -> std::collections::HashMap<String, std::collections::HashMap<String, FnDecl>> {
    let mut out: std::collections::HashMap<String, std::collections::HashMap<String, FnDecl>> =
        std::collections::HashMap::new();
    for d in decls {
        out.entry(d.module_name.clone())
            .or_default()
            .insert(d.fn_name.clone(), d.clone());
    }
    out
}

fn synthesize_call_args_for_fn(
    d: &FnDecl,
    object_vars_by_type: &std::collections::HashMap<String, String>,
    has_coin: bool,
) -> Option<Vec<String>> {
    let mut args = Vec::new();
    for p in &d.params {
        let t = p.ty.trim();
        if t.starts_with('&')
            && !t.contains("TxContext")
            && !t.contains("Coin<")
            && !t.contains("Coin <")
        {
            let ty = normalize_param_object_type(t);
            let key = type_key_from_type_name(&ty);
            let var = object_vars_by_type.get(&key)?;
            if t.starts_with("&mut") {
                args.push(format!("&mut {}", var));
            } else {
                args.push(format!("&{}", var));
            }
        } else if t.contains("TxContext") {
            args.push("test_scenario::ctx(&mut scenario)".to_string());
        } else if t.contains("Coin<") || t.contains("Coin <") {
            if !has_coin {
                return None;
            }
            if t.starts_with("&mut") {
                args.push("&mut coin".to_string());
            } else {
                args.push("&coin".to_string());
            }
        } else if t == "u64" {
            args.push("1".to_string());
        } else if t == "bool" {
            args.push("false".to_string());
        } else if t == "address" {
            args.push("OTHER".to_string());
        } else if is_option_type(t) {
            args.push(option_none_expr_for_type(t));
        } else if is_string_type(t) {
            args.push("std::string::utf8(b\"tidewalker\")".to_string());
        } else {
            return None;
        }
    }
    Some(args)
}

fn build_chained_effect_map(
    decls: &[FnDecl],
    max_depth: usize,
) -> std::collections::HashMap<String, Vec<NumericEffect>> {
    let mut by_module_and_fn: std::collections::HashMap<
        String,
        std::collections::HashMap<String, &FnDecl>,
    > = std::collections::HashMap::new();
    for d in decls {
        by_module_and_fn
            .entry(d.module_name.clone())
            .or_default()
            .insert(d.fn_name.clone(), d);
    }

    let mut cache: std::collections::HashMap<String, Vec<NumericEffect>> =
        std::collections::HashMap::new();
    for d in decls {
        let mut visiting: std::collections::HashSet<String> = std::collections::HashSet::new();
        let key = format!("{}::{}", d.module_name, d.fn_name);
        let resolved = collect_effects_for_fn(
            d,
            &by_module_and_fn,
            &mut cache,
            &mut visiting,
            0,
            max_depth,
        );
        cache.insert(key, resolved);
    }
    cache
}

fn build_chained_vector_effect_map(
    decls: &[FnDecl],
    max_depth: usize,
) -> std::collections::HashMap<String, Vec<VectorEffect>> {
    let mut by_module_and_fn: std::collections::HashMap<
        String,
        std::collections::HashMap<String, &FnDecl>,
    > = std::collections::HashMap::new();
    for d in decls {
        by_module_and_fn
            .entry(d.module_name.clone())
            .or_default()
            .insert(d.fn_name.clone(), d);
    }
    let mut cache: std::collections::HashMap<String, Vec<VectorEffect>> =
        std::collections::HashMap::new();
    for d in decls {
        let mut visiting: std::collections::HashSet<String> = std::collections::HashSet::new();
        let key = format!("{}::{}", d.module_name, d.fn_name);
        let resolved = collect_vector_effects_for_fn(
            d,
            &by_module_and_fn,
            &mut cache,
            &mut visiting,
            0,
            max_depth,
        );
        cache.insert(key, resolved);
    }
    cache
}

fn build_chained_option_effect_map(
    decls: &[FnDecl],
    max_depth: usize,
) -> std::collections::HashMap<String, Vec<OptionEffect>> {
    let mut by_module_and_fn: std::collections::HashMap<
        String,
        std::collections::HashMap<String, &FnDecl>,
    > = std::collections::HashMap::new();
    for d in decls {
        by_module_and_fn
            .entry(d.module_name.clone())
            .or_default()
            .insert(d.fn_name.clone(), d);
    }
    let mut cache: std::collections::HashMap<String, Vec<OptionEffect>> =
        std::collections::HashMap::new();
    for d in decls {
        let mut visiting: std::collections::HashSet<String> = std::collections::HashSet::new();
        let key = format!("{}::{}", d.module_name, d.fn_name);
        let resolved = collect_option_effects_for_fn(
            d,
            &by_module_and_fn,
            &mut cache,
            &mut visiting,
            0,
            max_depth,
        );
        cache.insert(key, resolved);
    }
    cache
}

fn build_chained_string_effect_map(
    decls: &[FnDecl],
    max_depth: usize,
) -> std::collections::HashMap<String, Vec<StringEffect>> {
    let mut by_module_and_fn: std::collections::HashMap<
        String,
        std::collections::HashMap<String, &FnDecl>,
    > = std::collections::HashMap::new();
    for d in decls {
        by_module_and_fn
            .entry(d.module_name.clone())
            .or_default()
            .insert(d.fn_name.clone(), d);
    }
    let mut cache: std::collections::HashMap<String, Vec<StringEffect>> =
        std::collections::HashMap::new();
    for d in decls {
        let mut visiting: std::collections::HashSet<String> = std::collections::HashSet::new();
        let key = format!("{}::{}", d.module_name, d.fn_name);
        let resolved = collect_string_effects_for_fn(
            d,
            &by_module_and_fn,
            &mut cache,
            &mut visiting,
            0,
            max_depth,
        );
        cache.insert(key, resolved);
    }
    cache
}

fn build_deep_overflow_map(
    decls: &[FnDecl],
    max_depth: usize,
) -> std::collections::HashMap<String, std::collections::HashSet<String>> {
    let mut by_module_and_fn: std::collections::HashMap<
        String,
        std::collections::HashMap<String, &FnDecl>,
    > = std::collections::HashMap::new();
    for d in decls {
        by_module_and_fn
            .entry(d.module_name.clone())
            .or_default()
            .insert(d.fn_name.clone(), d);
    }

    let mut cache: std::collections::HashMap<String, std::collections::HashSet<String>> =
        std::collections::HashMap::new();
    for d in decls {
        let mut visiting: std::collections::HashSet<String> = std::collections::HashSet::new();
        let key = format!("{}::{}", d.module_name, d.fn_name);
        let resolved = collect_deep_overflow_for_fn(
            d,
            &by_module_and_fn,
            &mut cache,
            &mut visiting,
            0,
            max_depth,
        );
        cache.insert(key, resolved);
    }
    cache
}

fn collect_deep_overflow_for_fn(
    d: &FnDecl,
    by_module_and_fn: &std::collections::HashMap<
        String,
        std::collections::HashMap<String, &FnDecl>,
    >,
    cache: &mut std::collections::HashMap<String, std::collections::HashSet<String>>,
    visiting: &mut std::collections::HashSet<String>,
    depth: usize,
    max_depth: usize,
) -> std::collections::HashSet<String> {
    let key = format!("{}::{}", d.module_name, d.fn_name);
    if let Some(cached) = cache.get(&key) {
        return cached.clone();
    }
    if depth > max_depth || visiting.contains(&key) {
        return collect_forwarded_mut_paths_at_cutoff(d, by_module_and_fn.get(&d.module_name));
    }
    visiting.insert(key.clone());

    let mut out: std::collections::HashSet<String> = std::collections::HashSet::new();
    if let Some(module_map) = by_module_and_fn.get(&d.module_name) {
        for call in &d.calls {
            let callee = match module_map.get(&call.callee_fn) {
                Some(c) => *c,
                None => continue,
            };
            let child_paths = collect_deep_overflow_for_fn(
                callee,
                by_module_and_fn,
                cache,
                visiting,
                depth + 1,
                max_depth,
            );
            for path in child_paths {
                if let Some(mapped) = map_child_overflow_path_to_caller(&path, callee, call) {
                    out.insert(mapped);
                } else {
                    // If remapping fails (alias/expression), conservatively mark all mutable
                    // parameters of the caller as potentially changed.
                    for p in &d.params {
                        if p.ty.trim().starts_with("&mut") {
                            out.insert(p.name.clone());
                        }
                    }
                }
            }
        }
    }

    visiting.remove(&key);
    cache.insert(key, out.clone());
    out
}

fn collect_forwarded_mut_paths_at_cutoff(
    d: &FnDecl,
    module_map: Option<&std::collections::HashMap<String, &FnDecl>>,
) -> std::collections::HashSet<String> {
    let mut out: std::collections::HashSet<String> = std::collections::HashSet::new();
    let Some(module_map) = module_map else {
        return out;
    };
    let mut had_unresolved = false;
    for call in &d.calls {
        let callee = match module_map.get(&call.callee_fn) {
            Some(c) => *c,
            None => continue,
        };
        for (idx, param) in callee.params.iter().enumerate() {
            if !param.ty.trim().starts_with("&mut") {
                continue;
            }
            let arg = match call.arg_exprs.get(idx) {
                Some(a) => a,
                None => {
                    had_unresolved = true;
                    continue;
                }
            };
            if let Some(path) = canonicalize_arg_path(arg) {
                out.insert(path);
            } else {
                had_unresolved = true;
            }
        }
    }

    if had_unresolved {
        for p in &d.params {
            if p.ty.trim().starts_with("&mut") {
                out.insert(p.name.clone());
            }
        }
    }
    out
}

fn map_child_overflow_path_to_caller(
    child_path: &str,
    callee: &FnDecl,
    call: &CallSite,
) -> Option<String> {
    let (head, tail) = split_path_head_tail(child_path)?;
    let idx = callee.params.iter().position(|p| p.name == head)?;
    let arg = call.arg_exprs.get(idx)?;
    let arg_path = canonicalize_arg_path(arg)?;
    Some(format!("{}{}", arg_path, tail))
}

fn split_path_head_tail(path: &str) -> Option<(&str, &str)> {
    let first = path.split('.').next()?.trim();
    if !is_ident(first) {
        return None;
    }
    let tail = path.strip_prefix(first)?;
    Some((first, tail))
}

fn canonicalize_arg_path(expr: &str) -> Option<String> {
    let stripped = strip_ref_and_parens(expr.trim());
    if let Some((base, field)) = parse_field_access(stripped) {
        return Some(format!("{}.{}", base, field));
    }
    if is_ident(stripped) {
        return Some(stripped.to_string());
    }
    None
}

fn strip_ref_and_parens(raw: &str) -> &str {
    let mut s = raw.trim();
    loop {
        let mut changed = false;
        if let Some(rest) = s.strip_prefix("&mut") {
            s = rest.trim();
            changed = true;
        } else if let Some(rest) = s.strip_prefix('&') {
            s = rest.trim();
            changed = true;
        }
        if s.starts_with('(') && s.ends_with(')') && s.len() >= 2 {
            s = s[1..s.len() - 1].trim();
            changed = true;
        }
        if !changed {
            break;
        }
    }
    s
}

fn collect_option_effects_for_fn(
    d: &FnDecl,
    by_module_and_fn: &std::collections::HashMap<
        String,
        std::collections::HashMap<String, &FnDecl>,
    >,
    cache: &mut std::collections::HashMap<String, Vec<OptionEffect>>,
    visiting: &mut std::collections::HashSet<String>,
    depth: usize,
    max_depth: usize,
) -> Vec<OptionEffect> {
    let key = format!("{}::{}", d.module_name, d.fn_name);
    if let Some(cached) = cache.get(&key) {
        return cached.clone();
    }
    if depth > max_depth || visiting.contains(&key) {
        return d.option_effects.clone();
    }
    visiting.insert(key.clone());

    let mut out = d.option_effects.clone();
    if let Some(module_map) = by_module_and_fn.get(&d.module_name) {
        for call in &d.calls {
            let callee = match module_map.get(&call.callee_fn) {
                Some(c) => *c,
                None => continue,
            };
            let callee_effects = collect_option_effects_for_fn(
                callee,
                by_module_and_fn,
                cache,
                visiting,
                depth + 1,
                max_depth,
            );
            for eff in callee_effects {
                let callee_idx = callee.params.iter().position(|p| p.name == eff.base_var);
                let idx = match callee_idx {
                    Some(v) => v,
                    None => continue,
                };
                let arg = match call.arg_exprs.get(idx) {
                    Some(a) => a.trim(),
                    None => continue,
                };
                if !is_ident(arg) {
                    continue;
                }
                out.push(OptionEffect {
                    base_var: arg.to_string(),
                    field: eff.field,
                    op: eff.op,
                });
            }
        }
    }

    let mut deduped = Vec::new();
    let mut seen: std::collections::HashSet<String> = std::collections::HashSet::new();
    for eff in out {
        let sig = format!("{}::{}::{:?}", eff.base_var, eff.field, eff.op);
        if seen.insert(sig) {
            deduped.push(eff);
        }
    }

    visiting.remove(&key);
    cache.insert(key, deduped.clone());
    deduped
}

fn collect_vector_effects_for_fn(
    d: &FnDecl,
    by_module_and_fn: &std::collections::HashMap<
        String,
        std::collections::HashMap<String, &FnDecl>,
    >,
    cache: &mut std::collections::HashMap<String, Vec<VectorEffect>>,
    visiting: &mut std::collections::HashSet<String>,
    depth: usize,
    max_depth: usize,
) -> Vec<VectorEffect> {
    let key = format!("{}::{}", d.module_name, d.fn_name);
    if let Some(cached) = cache.get(&key) {
        return cached.clone();
    }
    if depth > max_depth || visiting.contains(&key) {
        return d.vector_effects.clone();
    }
    visiting.insert(key.clone());

    let mut out = d.vector_effects.clone();
    if let Some(module_map) = by_module_and_fn.get(&d.module_name) {
        for call in &d.calls {
            let callee = match module_map.get(&call.callee_fn) {
                Some(c) => *c,
                None => continue,
            };
            let callee_effects = collect_vector_effects_for_fn(
                callee,
                by_module_and_fn,
                cache,
                visiting,
                depth + 1,
                max_depth,
            );
            for eff in callee_effects {
                let callee_idx = callee.params.iter().position(|p| p.name == eff.base_var);
                let idx = match callee_idx {
                    Some(v) => v,
                    None => continue,
                };
                let arg = match call.arg_exprs.get(idx) {
                    Some(a) => a.trim(),
                    None => continue,
                };
                if !is_ident(arg) {
                    continue;
                }
                out.push(VectorEffect {
                    base_var: arg.to_string(),
                    field: eff.field,
                    op: eff.op,
                });
            }
        }
    }

    visiting.remove(&key);
    cache.insert(key, out.clone());
    out
}

fn collect_string_effects_for_fn(
    d: &FnDecl,
    by_module_and_fn: &std::collections::HashMap<
        String,
        std::collections::HashMap<String, &FnDecl>,
    >,
    cache: &mut std::collections::HashMap<String, Vec<StringEffect>>,
    visiting: &mut std::collections::HashSet<String>,
    depth: usize,
    max_depth: usize,
) -> Vec<StringEffect> {
    let key = format!("{}::{}", d.module_name, d.fn_name);
    if let Some(cached) = cache.get(&key) {
        return cached.clone();
    }
    if depth > max_depth || visiting.contains(&key) {
        return d.string_effects.clone();
    }
    visiting.insert(key.clone());

    let mut out = d.string_effects.clone();
    if let Some(module_map) = by_module_and_fn.get(&d.module_name) {
        for call in &d.calls {
            let callee = match module_map.get(&call.callee_fn) {
                Some(c) => *c,
                None => continue,
            };
            let callee_effects = collect_string_effects_for_fn(
                callee,
                by_module_and_fn,
                cache,
                visiting,
                depth + 1,
                max_depth,
            );
            for eff in callee_effects {
                let callee_idx = callee.params.iter().position(|p| p.name == eff.base_var);
                let idx = match callee_idx {
                    Some(v) => v,
                    None => continue,
                };
                let arg = match call.arg_exprs.get(idx) {
                    Some(a) => a.trim(),
                    None => continue,
                };
                if !is_ident(arg) {
                    continue;
                }
                out.push(StringEffect {
                    base_var: arg.to_string(),
                    field: eff.field,
                });
            }
        }
    }

    let mut deduped = Vec::new();
    let mut seen: std::collections::HashSet<String> = std::collections::HashSet::new();
    for eff in out {
        let sig = format!("{}::{}", eff.base_var, eff.field);
        if seen.insert(sig) {
            deduped.push(eff);
        }
    }

    visiting.remove(&key);
    cache.insert(key, deduped.clone());
    deduped
}

fn collect_effects_for_fn(
    d: &FnDecl,
    by_module_and_fn: &std::collections::HashMap<
        String,
        std::collections::HashMap<String, &FnDecl>,
    >,
    cache: &mut std::collections::HashMap<String, Vec<NumericEffect>>,
    visiting: &mut std::collections::HashSet<String>,
    depth: usize,
    max_depth: usize,
) -> Vec<NumericEffect> {
    let key = format!("{}::{}", d.module_name, d.fn_name);
    if let Some(cached) = cache.get(&key) {
        return cached.clone();
    }
    if depth > max_depth || visiting.contains(&key) {
        return d.numeric_effects.clone();
    }
    visiting.insert(key.clone());

    let mut out = d.numeric_effects.clone();
    if let Some(module_map) = by_module_and_fn.get(&d.module_name) {
        for call in &d.calls {
            let callee = match module_map.get(&call.callee_fn) {
                Some(c) => *c,
                None => continue,
            };
            let callee_effects = collect_effects_for_fn(
                callee,
                by_module_and_fn,
                cache,
                visiting,
                depth + 1,
                max_depth,
            );
            for eff in callee_effects {
                let callee_idx = callee.params.iter().position(|p| p.name == eff.base_var);
                let idx = match callee_idx {
                    Some(v) => v,
                    None => continue,
                };
                let arg = match call.arg_exprs.get(idx) {
                    Some(a) => a.trim(),
                    None => continue,
                };
                if !is_ident(arg) {
                    continue;
                }
                out.push(NumericEffect {
                    base_var: arg.to_string(),
                    field: eff.field,
                    op: eff.op,
                });
            }
        }
    }

    let mut deduped = Vec::new();
    let mut seen: std::collections::HashSet<String> = std::collections::HashSet::new();
    for eff in out {
        let sig = format!("{}::{}::{:?}", eff.base_var, eff.field, eff.op);
        if seen.insert(sig) {
            deduped.push(eff);
        }
    }

    visiting.remove(&key);
    cache.insert(key, deduped.clone());
    deduped
}

fn resolve_read_expr(
    d: &FnDecl,
    eff: &NumericEffect,
    runtime_var: &str,
    accessor_map: &std::collections::HashMap<String, Vec<AccessorSig>>,
) -> Option<String> {
    let param = d.params.iter().find(|p| p.name == eff.base_var)?;
    let param_obj_ty = normalize_param_object_type(&param.ty);
    let module_accessors = accessor_map.get(&d.module_name)?;
    let has_accessor = module_accessors
        .iter()
        .any(|a| a.param_ty == param_obj_ty && a.fn_name == eff.field);
    if has_accessor {
        Some(format!(
            "{}::{}(&{})",
            d.module_name, eff.field, runtime_var
        ))
    } else {
        None
    }
}

fn overflow_may_affect_target(
    deep_overflow_paths: &std::collections::HashSet<String>,
    base_var: &str,
    field: &str,
) -> bool {
    let exact = format!("{}.{}", base_var, field);
    for p in deep_overflow_paths {
        if p == base_var || p == &exact {
            return true;
        }
    }
    false
}

fn build_numeric_assertion_lines(
    d: &FnDecl,
    numeric_effects: &[NumericEffect],
    param_runtime: &std::collections::HashMap<String, String>,
    param_arg_values: &std::collections::HashMap<String, String>,
    accessor_map: &std::collections::HashMap<String, Vec<AccessorSig>>,
    deep_overflow_paths: &std::collections::HashSet<String>,
) -> (Vec<String>, Vec<String>, StateChangeSummary) {
    let mut before = Vec::new();
    let mut after = Vec::new();
    let mut summary = StateChangeSummary::default();
    let mut seen_targets: std::collections::HashSet<String> = std::collections::HashSet::new();
    let mut direct_effect_counts: std::collections::HashMap<String, usize> =
        std::collections::HashMap::new();
    for eff in &d.numeric_effects {
        let key = format!("{}.{}", eff.base_var, eff.field);
        *direct_effect_counts.entry(key).or_insert(0) += 1;
    }
    let has_internal_calls = !d.calls.is_empty();
    let mut idx = 0usize;

    for eff in numeric_effects {
        let target_label = format!("operator {}.{}", eff.base_var, eff.field);
        if overflow_may_affect_target(deep_overflow_paths, &eff.base_var, &eff.field) {
            summary.add_potential(target_label);
            continue;
        }
        let runtime_var = match param_runtime.get(&eff.base_var) {
            Some(v) => v,
            None => {
                summary.add_potential(target_label);
                continue;
            }
        };
        let key = format!("{}.{}", runtime_var, eff.field);
        if seen_targets.contains(&key) {
            continue;
        }
        let read_expr = match resolve_read_expr(d, eff, runtime_var, accessor_map) {
            Some(expr) => expr,
            None => {
                summary.add_potential(target_label);
                continue;
            }
        };
        seen_targets.insert(key.clone());

        let before_name = format!(
            "before_{}_{}",
            sanitize_ident(runtime_var),
            sanitize_ident(&eff.field)
        );
        let after_name = format!(
            "after_{}_{}",
            sanitize_ident(runtime_var),
            sanitize_ident(&eff.field)
        );
        before.push(format!("let {} = {};", before_name, read_expr));
        after.push(format!("let {} = {};", after_name, read_expr));

        let direct_key = format!("{}.{}", eff.base_var, eff.field);
        let direct_count = direct_effect_counts.get(&direct_key).copied().unwrap_or(0);
        let prefer_unqualified = has_internal_calls || direct_count > 1;

        let exact_assert = if !prefer_unqualified {
            build_exact_assert_line(
                &eff.op,
                &after_name,
                &before_name,
                param_arg_values,
                900 + idx as u64,
            )
        } else {
            None
        };

        if let Some(line) = exact_assert {
            after.push(line);
            summary.add_asserted(target_label);
        } else {
            after.push(format!(
                "assert!({} != {}, {});",
                after_name,
                before_name,
                900 + idx as u64
            ));
            summary.add_asserted(target_label);
        }
        idx += 1;
    }

    (before, after, summary)
}

fn resolve_numeric_operand(
    token: &str,
    param_arg_values: &std::collections::HashMap<String, String>,
) -> Option<String> {
    if parse_numeric_literal(token).is_some() {
        return Some(token.to_string());
    }
    if is_ident(token) {
        let bound = param_arg_values.get(token)?;
        if parse_numeric_literal(bound).is_some() {
            return Some(bound.clone());
        }
    }
    None
}

fn build_exact_assert_line(
    op: &NumericOp,
    after_name: &str,
    before_name: &str,
    param_arg_values: &std::collections::HashMap<String, String>,
    code: u64,
) -> Option<String> {
    match op {
        NumericOp::Add(v) => Some(format!(
            "assert!({} == {} + {}, {});",
            after_name,
            before_name,
            resolve_numeric_operand(v, param_arg_values)?,
            code
        )),
        NumericOp::Sub(v) => Some(format!(
            "assert!({} == {} - {}, {});",
            after_name,
            before_name,
            resolve_numeric_operand(v, param_arg_values)?,
            code
        )),
        NumericOp::Mul(v) => Some(format!(
            "assert!({} == {} * {}, {});",
            after_name,
            before_name,
            resolve_numeric_operand(v, param_arg_values)?,
            code
        )),
        NumericOp::Div(v) => Some(format!(
            "assert!({} == {} / {}, {});",
            after_name,
            before_name,
            resolve_numeric_operand(v, param_arg_values)?,
            code
        )),
        NumericOp::Mod(v) => Some(format!(
            "assert!({} == {} % {}, {});",
            after_name,
            before_name,
            resolve_numeric_operand(v, param_arg_values)?,
            code
        )),
        NumericOp::Set(v) => Some(format!(
            "assert!({} == {}, {});",
            after_name,
            resolve_numeric_operand(v, param_arg_values)?,
            code
        )),
        NumericOp::Changed => None,
    }
}

fn resolve_vector_len_expr(
    d: &FnDecl,
    base_var: &str,
    field: &str,
    runtime_var: &str,
    accessor_map: &std::collections::HashMap<String, Vec<AccessorSig>>,
) -> Option<String> {
    let param = d.params.iter().find(|p| p.name == base_var)?;
    let param_obj_ty = normalize_param_object_type(&param.ty);
    let module_accessors = accessor_map.get(&d.module_name)?;
    let preferred = format!("{}_len", field);
    let alt = format!("len_{}", field);
    let accessor = module_accessors
        .iter()
        .find(|a| a.param_ty == param_obj_ty && (a.fn_name == preferred || a.fn_name == alt))?;
    Some(format!(
        "{}::{}(&{})",
        d.module_name, accessor.fn_name, runtime_var
    ))
}

fn build_vector_assertion_lines(
    d: &FnDecl,
    vector_effects: &[VectorEffect],
    param_runtime: &std::collections::HashMap<String, String>,
    accessor_map: &std::collections::HashMap<String, Vec<AccessorSig>>,
    deep_overflow_paths: &std::collections::HashSet<String>,
) -> (Vec<String>, Vec<String>, StateChangeSummary) {
    let mut before = Vec::new();
    let mut after = Vec::new();
    let mut summary = StateChangeSummary::default();
    if vector_effects.is_empty() {
        return (before, after, summary);
    }

    let mut grouped: std::collections::BTreeMap<String, Vec<&VectorEffect>> =
        std::collections::BTreeMap::new();
    for eff in vector_effects {
        grouped
            .entry(format!("{}.{}", eff.base_var, eff.field))
            .or_default()
            .push(eff);
    }

    let has_internal_calls = !d.calls.is_empty();
    let mut potential_targets: std::collections::BTreeSet<String> = std::collections::BTreeSet::new();
    let mut seen_len_snapshots: std::collections::HashSet<String> = std::collections::HashSet::new();
    let mut idx = 0u64;

    for (target, effects) in grouped {
        let first = effects[0];
        if overflow_may_affect_target(deep_overflow_paths, &first.base_var, &first.field) {
            potential_targets.insert(target);
            continue;
        }
        let runtime_var = match param_runtime.get(&first.base_var) {
            Some(v) => v,
            None => {
                potential_targets.insert(target);
                continue;
            }
        };
        if has_internal_calls || effects.len() != 1 {
            potential_targets.insert(target);
            continue;
        }
        let read_expr =
            match resolve_vector_len_expr(d, &first.base_var, &first.field, runtime_var, accessor_map) {
                Some(v) => v,
                None => {
                    potential_targets.insert(target);
                    continue;
                }
            };
        let before_name = format!(
            "before_{}_{}_len",
            sanitize_ident(runtime_var),
            sanitize_ident(&first.field)
        );
        let after_name = format!(
            "after_{}_{}_len",
            sanitize_ident(runtime_var),
            sanitize_ident(&first.field)
        );
        if seen_len_snapshots.insert(before_name.clone()) {
            before.push(format!("let {} = {};", before_name, read_expr));
        }
        after.push(format!("let {} = {};", after_name, read_expr));
        match &first.op {
            VectorOp::PushBack | VectorOp::Insert => after.push(format!(
                "assert!({} == {} + 1, {});",
                after_name,
                before_name,
                960 + idx
            )),
            VectorOp::PopBack | VectorOp::Remove | VectorOp::SwapRemove => after.push(format!(
                "assert!({} + 1 == {}, {});",
                after_name,
                before_name,
                960 + idx
            )),
            VectorOp::Append {
                src_base_var,
                src_field,
            } => {
                let src_runtime_var = match param_runtime.get(src_base_var) {
                    Some(v) => v,
                    None => {
                        potential_targets.insert(target);
                        idx += 1;
                        continue;
                    }
                };
                let src_len_expr = match resolve_vector_len_expr(
                    d,
                    src_base_var,
                    src_field,
                    src_runtime_var,
                    accessor_map,
                ) {
                    Some(v) => v,
                    None => {
                        potential_targets.insert(target);
                        idx += 1;
                        continue;
                    }
                };
                let src_before_name = format!(
                    "before_{}_{}_len",
                    sanitize_ident(src_runtime_var),
                    sanitize_ident(src_field)
                );
                if seen_len_snapshots.insert(src_before_name.clone()) {
                    before.push(format!("let {} = {};", src_before_name, src_len_expr));
                }
                after.push(format!(
                    "assert!({} == {} + {}, {});",
                    after_name,
                    before_name,
                    src_before_name,
                    960 + idx
                ));
            }
            VectorOp::ContentChanged => {
                potential_targets.insert(target);
                idx += 1;
                continue;
            }
        }
        summary.add_asserted(format!("vector {}", target));
        idx += 1;
    }

    for t in potential_targets {
        summary.add_potential(format!("vector {}", t));
    }

    (before, after, summary)
}

fn resolve_option_is_some_expr(
    d: &FnDecl,
    eff: &OptionEffect,
    runtime_var: &str,
    option_accessor_map: &std::collections::HashMap<String, Vec<OptionAccessorSig>>,
) -> Option<String> {
    let param = d.params.iter().find(|p| p.name == eff.base_var)?;
    let param_obj_ty = normalize_param_object_type(&param.ty);
    let module_accessors = option_accessor_map.get(&d.module_name)?;
    let accessor = module_accessors.iter().find(|a| {
        a.param_ty == param_obj_ty && a.field == eff.field
    })?;
    if accessor.is_some_when_true {
        Some(format!(
            "{}::{}(&{})",
            d.module_name, accessor.fn_name, runtime_var
        ))
    } else {
        Some(format!(
            "!({}::{}(&{}))",
            d.module_name, accessor.fn_name, runtime_var
        ))
    }
}

fn build_option_assertion_lines(
    d: &FnDecl,
    option_effects: &[OptionEffect],
    param_runtime: &std::collections::HashMap<String, String>,
    option_accessor_map: &std::collections::HashMap<String, Vec<OptionAccessorSig>>,
    deep_overflow_paths: &std::collections::HashSet<String>,
) -> (Vec<String>, Vec<String>, StateChangeSummary) {
    let mut before = Vec::new();
    let mut after = Vec::new();
    let mut summary = StateChangeSummary::default();
    if option_effects.is_empty() {
        return (before, after, summary);
    }

    let mut grouped: std::collections::BTreeMap<String, Vec<&OptionEffect>> =
        std::collections::BTreeMap::new();
    for eff in option_effects {
        grouped
            .entry(format!("{}.{}", eff.base_var, eff.field))
            .or_default()
            .push(eff);
    }

    let mut direct_effect_counts: std::collections::HashMap<String, usize> =
        std::collections::HashMap::new();
    for eff in &d.option_effects {
        let key = format!("{}.{}", eff.base_var, eff.field);
        *direct_effect_counts.entry(key).or_insert(0) += 1;
    }

    let has_internal_calls = !d.calls.is_empty();
    let mut seen_before_snapshots: std::collections::HashSet<String> =
        std::collections::HashSet::new();
    let mut idx = 0u64;

    for (target, effects) in grouped {
        let first = effects[0];
        if overflow_may_affect_target(deep_overflow_paths, &first.base_var, &first.field) {
            summary.add_potential(format!("option {}", target));
            continue;
        }
        let runtime_var = match param_runtime.get(&first.base_var) {
            Some(v) => v,
            None => {
                summary.add_potential(format!("option {}", target));
                continue;
            }
        };
        let read_expr =
            match resolve_option_is_some_expr(d, first, runtime_var, option_accessor_map) {
                Some(v) => v,
                None => {
                    summary.add_potential(format!("option {}", target));
                    continue;
                }
            };
        let before_name = format!(
            "before_{}_{}_is_some",
            sanitize_ident(runtime_var),
            sanitize_ident(&first.field)
        );
        let after_name = format!(
            "after_{}_{}_is_some",
            sanitize_ident(runtime_var),
            sanitize_ident(&first.field)
        );

        let direct_key = format!("{}.{}", first.base_var, first.field);
        let direct_count = direct_effect_counts.get(&direct_key).copied().unwrap_or(0);
        let prefer_generic = has_internal_calls || direct_count > 1 || effects.len() != 1;
        let needs_before = prefer_generic || matches!(first.op, OptionOp::Changed);

        if needs_before && seen_before_snapshots.insert(before_name.clone()) {
            before.push(format!("let {} = {};", before_name, read_expr.clone()));
        }
        after.push(format!("let {} = {};", after_name, read_expr));

        if prefer_generic {
            after.push(format!(
                "assert!({} != {}, {});",
                after_name,
                before_name,
                980 + idx
            ));
            summary.add_asserted(format!("option {}", target));
            idx += 1;
            continue;
        }

        match first.op {
            OptionOp::SetSome => after.push(format!("assert!({}, {});", after_name, 980 + idx)),
            OptionOp::SetNone => {
                after.push(format!("assert!(!{}, {});", after_name, 980 + idx))
            }
            OptionOp::Changed => after.push(format!(
                "assert!({} != {}, {});",
                after_name,
                before_name,
                980 + idx
            )),
        }
        summary.add_asserted(format!("option {}", target));
        idx += 1;
    }

    (before, after, summary)
}

fn build_string_summary(
    string_effects: &[StringEffect],
    param_runtime: &std::collections::HashMap<String, String>,
    deep_overflow_paths: &std::collections::HashSet<String>,
) -> StateChangeSummary {
    let mut summary = StateChangeSummary::default();
    for eff in string_effects {
        if overflow_may_affect_target(deep_overflow_paths, &eff.base_var, &eff.field) {
            summary.add_potential(format!("string {}.{}", eff.base_var, eff.field));
            continue;
        }
        if param_runtime.contains_key(&eff.base_var) {
            summary.add_potential(format!("string {}.{}", eff.base_var, eff.field));
        }
    }
    summary
}

fn build_deep_chain_summary(
    deep_overflow_paths: &std::collections::HashSet<String>,
) -> StateChangeSummary {
    let mut summary = StateChangeSummary::default();
    for path in deep_overflow_paths {
        if path.contains('.') {
            summary.add_potential(format!("state {}", path));
        }
    }
    summary
}

fn render_state_change_summary_lines(summary: &StateChangeSummary) -> Vec<String> {
    let mut out = Vec::new();
    if summary.asserted.is_empty() && summary.potential.is_empty() {
        return out;
    }
    out.push("// Tidewalker state changes:".to_string());
    if summary.asserted.is_empty() {
        out.push("// asserted: (none)".to_string());
    } else {
        out.push(format!(
            "// asserted: {}",
            summary.asserted.iter().cloned().collect::<Vec<_>>().join(", ")
        ));
    }
    if summary.potential.is_empty() {
        out.push("// potential_change: (none)".to_string());
    } else {
        out.push(format!(
            "// potential_change: {}",
            summary.potential.iter().cloned().collect::<Vec<_>>().join(", ")
        ));
    }
    out
}
